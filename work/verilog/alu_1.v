/*
   This file was generated automatically by Alchitry Labs version 1.1.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alu_1 (
    input [15:0] firstNumber,
    input [15:0] secondNumber,
    input [5:0] alufn,
    output reg [15:0] answer
  );
  
  
  
  wire [16-1:0] M_adder_answer;
  wire [1-1:0] M_adder_z;
  reg [16-1:0] M_adder_firstNumber;
  reg [16-1:0] M_adder_secondNumber;
  reg [2-1:0] M_adder_alufn;
  adder_3 adder (
    .firstNumber(M_adder_firstNumber),
    .secondNumber(M_adder_secondNumber),
    .alufn(M_adder_alufn),
    .answer(M_adder_answer),
    .z(M_adder_z)
  );
  
  wire [16-1:0] M_bool_answer;
  reg [16-1:0] M_bool_firstNumber;
  reg [16-1:0] M_bool_secondNumber;
  reg [4-1:0] M_bool_alufn;
  bool_4 bool (
    .firstNumber(M_bool_firstNumber),
    .secondNumber(M_bool_secondNumber),
    .alufn(M_bool_alufn),
    .answer(M_bool_answer)
  );
  
  wire [16-1:0] M_shft_answer;
  reg [16-1:0] M_shft_firstNumber;
  reg [4-1:0] M_shft_secondNumber;
  reg [2-1:0] M_shft_alufn;
  shft_5 shft (
    .firstNumber(M_shft_firstNumber),
    .secondNumber(M_shft_secondNumber),
    .alufn(M_shft_alufn),
    .answer(M_shft_answer)
  );
  
  wire [16-1:0] M_comp_answer;
  reg [1-1:0] M_comp_z;
  reg [1-1:0] M_comp_v;
  reg [1-1:0] M_comp_n;
  reg [2-1:0] M_comp_alufn;
  comp_6 comp (
    .z(M_comp_z),
    .v(M_comp_v),
    .n(M_comp_n),
    .alufn(M_comp_alufn),
    .answer(M_comp_answer)
  );
  
  wire [1-1:0] M_nv_v;
  wire [1-1:0] M_nv_n;
  reg [1-1:0] M_nv_a31;
  reg [1-1:0] M_nv_b31;
  reg [1-1:0] M_nv_s31;
  reg [1-1:0] M_nv_alufn;
  nv_7 nv (
    .a31(M_nv_a31),
    .b31(M_nv_b31),
    .s31(M_nv_s31),
    .alufn(M_nv_alufn),
    .v(M_nv_v),
    .n(M_nv_n)
  );
  
  always @* begin
    answer = 4'bxxxx;
    M_adder_firstNumber = 4'bxxxx;
    M_adder_secondNumber = 4'bxxxx;
    M_adder_alufn = 4'bxxxx;
    M_bool_firstNumber = 4'bxxxx;
    M_bool_secondNumber = 4'bxxxx;
    M_bool_alufn = 4'bxxxx;
    M_shft_firstNumber = 4'bxxxx;
    M_shft_secondNumber = 4'bxxxx;
    M_shft_alufn = 4'bxxxx;
    M_comp_z = 4'bxxxx;
    M_comp_v = 4'bxxxx;
    M_comp_n = 4'bxxxx;
    M_comp_alufn = 4'bxxxx;
    M_nv_a31 = 4'bxxxx;
    M_nv_b31 = 4'bxxxx;
    M_nv_s31 = 4'bxxxx;
    M_nv_alufn = 4'bxxxx;
    if (alufn[5+0-:1] == 1'h0 & alufn[4+0-:1] == 1'h0) begin
      M_adder_firstNumber = firstNumber;
      M_adder_secondNumber = secondNumber;
      M_adder_alufn = alufn[0+1-:2];
      answer = M_adder_answer;
    end
    if (alufn[5+0-:1] == 1'h0 & alufn[4+0-:1] == 1'h1) begin
      M_bool_firstNumber = firstNumber;
      M_bool_secondNumber = secondNumber;
      M_bool_alufn = alufn[0+3-:4];
      answer = M_bool_answer;
    end
    if (alufn[5+0-:1] == 1'h1 & alufn[4+0-:1] == 1'h0) begin
      M_shft_firstNumber = firstNumber;
      M_shft_secondNumber = secondNumber[0+3-:4];
      M_shft_alufn = alufn[0+1-:2];
      answer = M_shft_answer;
    end
    if (alufn[5+0-:1] == 1'h1 & alufn[4+0-:1] == 1'h1) begin
      M_adder_firstNumber = firstNumber;
      M_adder_secondNumber = secondNumber;
      M_adder_alufn = alufn[0+0-:1];
      M_nv_s31 = M_adder_answer[15+0-:1];
      M_nv_a31 = firstNumber[15+0-:1];
      M_nv_b31 = secondNumber[15+0-:1];
      M_comp_z = M_adder_z;
      M_comp_v = M_nv_v;
      M_comp_n = M_nv_n;
      M_comp_alufn = alufn[1+1-:2];
      answer = M_comp_answer;
    end
  end
endmodule
